### 数据库管理系统
能够科学地组织和存储数据，高效的获取和维护数据的系统软件。
主要功能是：数据定义，组织，存储，操作，事务管理，数据库建立和维护管理以及跟其他软件系统通信等。
主要功能：
- **数据定义功能**：DBMS提供数据定义语言(DDL)，通过DDL可以方便对数据库中的对象进行定义。（create，alter，drop等）
- **数据操纵功能**：DBMS提供数据操作语言(DML)，通过DML可以操作数据，实现如查询、插入、删除、修改等基本操作。（insert，update，delete等）
- **数据库的运行管理**：数据库在建立、运用和维护时由数据库管理系统统一管理、统一控制，以保证数据的安全性、完整性、多用户对数据的并发使用及发生故障后的系统恢复。
- **提供方便、有效地存取数据库信息的接口和工具**：编程人员可通过编程语言与数据库之间的接口进行数据库应用程序的开发。数据库管理员（Database Administrator，DBA）可通过提供的工具对数据库进行管理。
- **数据库的建立和维护功能**：数据库功能包括数据库初始数据的输入、转换功能，数据库的转储、恢复功能，数据库的重组织功能和性能监控、分析功能等。这些功能通常是由一些程序来完成。
##### 数据库的数据读取问题
1. **脏读**：读取未提交数据
	A事务读取B事务尚未提交的数据，此时如果B事务发生错误并执行回滚操作，A事务读到的数据就是脏数据。
2. **不可重复读**：前后读取多次，数据内容不一致
	事务A在执行读取操作，由于整个事务A比较大，前后读取同一条数据需要经历很长的时间，期间事务B执行更改操作，导致事务A读取到的两次数据不一致，成为不可重复读。
3. **幻读**：前后读取多次，数据总量不一致
	事务A在执行读取操作，需要两次统计数据的总量，前一次查询数据总量后，此时事务B执行了新增数据的操作并提交后，这个时候事务A读取到的数据总量不一致，像产生幻觉一样，成为幻读。

| 事务隔离级别              | 脏读 | 不可重复读 | 幻读 |
| ------------------------- | ---- | ---------- | ---- |
| 读未提交 read uncommitted |   √   |      √        |   √     |
| 读提交 read committed     |    ×  |      √        |   √     |
| 可重复读 repeatable read  |   ×    |    ×         | √     |
| 串行化 serializable       |  ×     |      ×       |  ×     |

##### 数据库的ACID性质
- **原子性** (Atomicity)
	事务时不可分割的最小操作单元，<font style="color:yellow">要么全部成功，要么全部失败。</font>
- 一致性 (Consistency)
	事务完成时，<font style="color:yellow">必须使所有的数据保持一致状态。</font>
- 隔离性 (Isolation)
	数据库提供的隔离机制，<font style="color:yellow">保证事务在不受外部并发操作影响的独立环境下运行。</font>
- 持久性 (Durability)
	事务一旦提交或回滚，<font style="color:yellow">它对数据库中的数据的改变是永久的。</font>
### 范式
1. 范式的概念
	- 第一范式(1NF)：列不能再分。
	- 第二范式(2NF)：消除部分函数依赖，完全依赖于主键。
	- 第三范式(3NF)：消除传递函数依赖，属性不依赖与其他非主属性。
	- BC范式(BCNF)：消除冗余
	- 多值依赖(MVD)：函数由所有关系决定
1. 范式的判断与分解
	- 2NF：若键是AB，F中若为{ A→C, AB→D }，对于C，只需要A就能推出，那么C部分函数依赖与键AB，这种情况就不是2NF。
	- 3NF：若键是AB，F若为{ AB→C, C→D }，这里不存在部分函数依赖。但是对于D，需要AB推出C后才能间接推出D，那么D传递函数依赖于AB，不满足于3NF。
		若要分解为3NF，同样将不符合要求的拿出来，即分为R<sub>1</sub>{ A, B, C }和R{ C, D }。
	- BCNF：若R是( A, B, C )，F是{ AC→B, AB→C, B→C }，候选键则是AC和AB。这里不存在部分函数依赖，但对于B→C来说，决定因素B不包含键，因此它不是BCNF。
	
		**将违背BCNF的函数依赖分解为满足BCNF的函数依赖：**
		1. 找一个违背BCNF的非平凡函数依赖 A<sub>1</sub>A<sub>2</sub> ...... A<sub>n</sub> → B<sub>1</sub>B<sub>2</sub> ...... B<sub>m</sub>。
		2. 把关系分解成两个关系 ：
			R1( A<sub>1</sub>A<sub>2</sub> ...... A<sub>n</sub> ,B<sub>1</sub>B<sub>2</sub> ...... B<sub>m</sub> )
			R2( A<sub>1</sub>A<sub>2</sub> ...... A<sub>n</sub> ,所有其他属性 )
		3. 若还是不满足BCNF，则再分解，直到满足为止。
3. 多值依赖的性质
	- 对称性：若 X→→Y，则 X→→Z，其中 Z=U-X-Y
	- 传递性：若 X→→Y，Y→→Z，则 X→→Z-Y
	- 合并性：若 X→→Y，X→→Z，则 X→→YZ
	- 分解性：若 X→→Y，X→→Z，则 X→→(Y∩Z)，X→→Z-Y，X→→Y-Z均成立
	- 函数依赖 可以看作 多值依赖 的特例
##### 例题
1. 设 U 是所有属性的集合，X、Y 和 Z 都是 U 的子集，且 Z=U-X-Y。下列说法不正确的 是： 
	A)若 X→→Y，则 X→→Z         B)若 X→Y，则 X→→Y 
	C)若 Z=Φ，则 X→→Y              D)若 X→→Y，且 Y’⊆Y，则 X→→Y’
	解：
	
### 闭包算法
要求某属性组的闭包，首先设有集合X，令X={该属性组}。
X<sup>0</sup>=自身
X<sup>1</sup>=X<sup>0</sup>中的属性所能推出的
当X<sup>1</sup>不等于X<sup>0</sup>时，X<sup>2</sup>=X<sup>1</sup>中的属性能所推出的
依次类推，直到X<sup>n</sup>=X<sup>n-1</sup>，就求得了属性组的闭包(X)<sub>F</sub><sup>+</sup>


### 最小函数依赖集
1. 拆分右侧
	将 A→BC 拆成 A→B, A→C
2. 去除自身求闭包
	若有AB→C, BC→E, AE→G, 去除AB自身能推出的C，基于剩余的依赖关系求AB的闭包，若AB通过剩余的关系也能求出C，那么删除AB→C这个依赖关系
3. 左侧最小化
	例如目前保留的关系有ABC→D,观察左边的ABC当中，A是否能有BC推出，B是否能由AC推出，C是否能由AB推出。假设C能被AB推出，那么左侧去掉C，更新为AB→D。
***
#### 例题
R( A, B, C, D, E, G )，有函数依赖 { BG→C, BD→E, DG→C, DAG→CB, AG→B, B→D }，求此模型最小化函数依赖集。

解：
1. 拆分右侧：{BG→C, BD→E, DG→C, DAG→C, DAG→B, AG→B, B→D}
2. 去除自身求闭包：
	1. 假设 BG 不能推出 C，{BG}<sup>+</sup>：{B,G,D,C,...}，BG通过剩余关系可以推出C，所以去掉。
		{BD→E, DG→C, DAG→C, DAG→B, AG→B, B→D}
		***
	2. 假设 BD 不能推出 E，{BD}<sup>+</sup>：{B,D}，BD 不能通过剩余关系推出 E，所以保留。
		{BD→E, DG→C, DAG→C, DAG→B, AG→B, B→D}
		***
	3. 假设 DG 不能推出 C，{DG}<sup>+</sup>：{D,G}，DG不能通过剩余关系推出 C，所以保留。
		{BD→E, DG→C, DAG→C, DAG→B, AG→B, B→D}
		***
	4. 假设 DAG 不能推出 C，{DAG}<sup>+</sup>：{D,A,G,B,E,C}，DAG通过剩余关系可以推出C，所以去掉。
		{BD→E, DG→C, DAG→B, AG→B, B→D}
		***
	5. 假设 DAG 不能推出 B，{DAG}<sup>+</sup>：{D,A,G,B,...}，DAG通过剩余关系可以推出B，所以去掉。
		{BD→E, DG→C,  AG→B, B→D}
		***
	6. 假设 AG 不能推出 B，{AG}<sup>+</sup>：{AG}，AG不能通过剩余关系推出 B，所以保留。
		{BD→E, DG→C,  AG→B, B→D}
		***
	7. 设 B不能推出 D，{B}<sup>+</sup>：{B}，B不能通过剩余关系推出 D，所以保留。
		{BD→E, DG→C,  AG→B, B→D}
3. 左侧最小化：
	BD→E，因为B→D，所以去掉D，更新为B→E；DG→C，D和G不能被对方推出，不变；
	AG→B，A和G不能被对方推出，不变；B→D已经是最小的，不变。
最后结果为F<sub>min</sub>={B→E, DG→C,  AG→B, B→D}

### 模式分解
模式分解的准则是**无损连接**和**保持函数依赖**
<b style="color:red">关系分解为BCNF时，无法同时拥有 无损连接 和 依赖保持 两种性质</b>
若只要求分解具有无损连接性，那么模式分解一定可以达到 BCNF

1. 无损连接：分解后再次自然连接，与分解前相同
	判断无损连接的方法：
	1. **画表格**。
		列表示所有的属性，有多少属性就画多少属性列。行表示分解后的关系，有几个关系就画几个关系行。
	2. **根据每一行关系进行判断**。
		找到关系中的每个属性对应的第几列，并在相应位置标为 a<sub>j</sub>，下标 j 是表格里的列数。其余关系中不存在的属性则标为 b<sub>ij</sub>，ij 是表格对应的行数和列数。
	3. **依次对函数依赖集里的各个依赖关系进行考察**。
		例如有XY→Z，在属性列中找到X和Y，观察X和Y的行列上是否有相同的标记（b的下标要相同）。若有，则查看它们对应在属性列Z上的各个标记。其中若有a<sub>j</sub>，则将属性列上的这些标记全部改为a<sub>j</sub> 。若没有a<sub>j</sub>，则找到 i 值最小的 b<sub>ij</sub>，将这些标记全部改为 b<sub>ij</sub> 。
	4. 反复执行以上操作，直到某一行全部变为a为止，则表明具有无损连接性，否则不具有无损连接性。
***
#### 例题
1. R(U, V, W, X, Y, Z)
	函数依赖集 F={U→V, W→Z, Y→U, WY→X}
	1. p1={WZ, VY, WXY, UV}
	2. p2={UVY, WXYZ}
	判断是否具有无损连接性。
	解：
	1. 画表格。
		![[Pasted image 20230809162049.png]]
		给出的分解中的属性作为行，关系模式中的属性作为列。行和列中匹配上的写a<sub>j</sub> (j 是列标)，其他的写b<sub>ij</sub> (i 是行标)
	2. 根据函数依赖进行考察
		1. U→V：U列里没有相同的，所以表格不变。
		2. W→Z：W列中有两个a3是相同的，要改变Z列。Z列中对应a3的行是a5和b36，要把b36改为a6.
			![[Pasted image 20230809163458.png]]
		3. Y→U：Y列中有2个相同的a5，对应的U列的行是b21，b31。发现没有a，就都改成行标最小的b21。
			![[Pasted image 20230809163741.png]]
		4. WY→X：WY两列里没有都相同的，所以表格不变。
		5. 第一遍发现没有任何一行都为a，所以重复上面的操作。
			U→V：U列有相同的b21，对应的V列的行为a2和b32，将b32改为a2
			![[Pasted image 20230809164617.png]]
		6.W→Z, Y→U, WY→X 都没有能够改变的了，考察结束。没有任何一行都为a
		所以p1不具有无损连接性。
		p2解法相同。
		![[无损连接表格.xlsx]]
2. **某图书管理系统中，有关系 R**
	R(图书索书号，图书 ISBN，图书条码号，馆藏地，书名，作者，出版社) 
	存在以下函数依赖： 
	- 图书索书号 → 书名，作者，出版社，图书 ISBN 
	- 图书 ISBN → 图书索书号 
	- 图书条码号 → 图书索书号，馆藏地 
	根据以上描述，
	1) 给出关系 R 的所有键。 
	2) 请问 R 最高满足第几范式？并给出理由。 
	3) 若 R 未达到 BCNF，请将关系 R 分解使之达到满足 BCNF。
	解：
	1. 关系R的键为 图书条码号
	2. 满足1NF。图书条码号 → 图书索书号，馆藏地；图书索书号 → 书名，作者，出版社，图书 ISBN 图书索书号 对于 图书条码号是传递函数依赖，违反了3NF；图书索书号函数依赖于图书条码号和图书ISBN，不完全依赖于主键，违反了2NF。所以关系R只满足1NF。
	3. 将R分为两个关系
		R1(图书条码号，图书索书号，图书ISBN)
		R2(图书条码号，书名，作者，出版社，馆藏地)时，
		满足BCNF。
		
1. 设某商业集团数据库中有关系模式 R: 
	 R(商品编号, 库存数量, 部门编号,负责人) 
	 R 中的元组描述了所销售的某商品的库存数量及其销售部门和负责人。
	 规定：每种商品只有 一个库存数量，只能在一个部门销售；每个部门只有一个负责人。 
	 1. 根据以上描述，给出关系 R 上的函数依赖。 
	 2. 找出关系 R 的所有键。 
	 3. 请问 R 最高达到第几范式？为什么？
	 
	 解：
	 1. 商品编号->库存数量
	     商品编号->部门编号
	     部门编号->负责人
	2. 商品编号
	3. 2NF。键只有商品编号一个，负责人对于商品编号是传递函数依赖，违背了3NF，但不违背2NF。

### 关系代数表达式优化策略
#### 优化遵循的原则
1. 选择运算尽可能先做
2. **投影运算**和**选择运算**同时进行(两者都是一元操作，一个元组能不能成为结果只取决于其本身)
3. 把投影同其前后的双目运算结合起来
4. 把某些选择同它前面要执行的笛卡儿积结合起来称为一个连接运算
5. 找出公共子表达式
#### 语法树
1. 将关系代数式子写成语法树形式
2. 可以下移的**选择**往下移到底
3. 把不需要的列投影去掉
4. 分组：一个笛卡尔积(二元运算)分为一组
##### 例题
Π<sub>A,F</sub> ( σ<sub>c="8"</sub> ( R×S ) )
	首先将关系代数写成语法树
	![[Pasted image 20230831180649.png]]
	将选择往下移到对应的表的位置
	![[Pasted image 20230831180816.png]]

### 关系代数解题方法
 1. 常规题（求某几个属性特定值）
	格式一般为 `Π____ (σ____ (表名⨝表名) )`
	并行的条件之间用 `, `隔开
	条件表达式的运算符：and，or，<>(不等于)，>=，<=，≺，≻，+
2. 除运算（求满足某属性全部值的其他属性）
	这种题是指满足B表某属性全部值的在A表上的其他属性。在出现<b style="color:yellow">全部</b>时，需要使用除运算。通常分别对A和B作投影运算，再对生成的子表进行除运算。
	A中包含属性x和y，B中包含属性y，且B中属性y的值为全集且无重复，求全部y的x写作：Π<sub>x,y</sub>(A)÷Π<sub>y</sub>(B)
3. 差运算
	Π<sub>字段名</sub>(表名) - Π<sub>字段名</sub>(σ<sub>条件</sub>(表名) )


### SQL
一般格式：
```sql
select distinct/all 目标列表达式
from 表名/视图名
where 条件表达式
group by 列名 
having 条件表达式
order by 列名 次序
```
创建表：
```sql
create table 表名
(
列名1 数据类型，
列名2 数据类型，
...
);
```
定义主键：
```sql
create table student
(
sid int not null primary key,
name varchar(255) not null,
sex varchar(255) not null
)
```
定义外键：
```sql
create table teacher
(
tid int not null primary key,
name varchar(255) not null,
sex varchar(255) not null,
sID int foreign key references student(sid)
)

create table student
(
sid int not null primary key,
name varchar(255) not null,
sex varchar(255) not null
)
```
基础部分：[[SQL语法]]

### E-R图
1. 画图（概念结构设计）
	实体：长方形
	关系：菱形
	属性：椭圆形；每个实体和关系都可以具有属性
	联系：1对1；1对多；多对多
	![[Pasted image 20230810201255.png]]
2. E-R图转换为关系模型（逻辑结构设计）
	1. 将各个实体的名字转换为各个关系模式的名字
	2. 实体的属性就是关系的属性，实体的码(键)就是关系的码(键)
	3. 实体间联系的转换
		- 1对1联系：在任意一方加入对方的主码并设为外码，并加入联系本身的属性。
		- 1对n联系：将1方的主码加入n方作为外码，并同时将联系的属性加入n方。
		- n对m联系：将联系本身转换为一个关系模式，将联系双方的主码加入其中设为码，并将联系的属性也加入其中。
##### 例题
1. 为某医院建立一个信息管理系统，系统需求如下： 
	1) 管理科室信息，包括科室名、地址和联系电话。 
	2) 每个科室有多位职员，每位职员属于一个科室，职员信息包括：姓名、性别、职 务（包括医生、护士、药剂师、会计等）、职称、电话等。职员可能重名。每个科室有一位 职员担任科室主任。 
	3) 药品信息包括：药品代码、药品名称、规格、计量单位、价格等。 
	4) 病人信息包括：病人代码，身份证号，姓名，病人性别，病人出生日期。 
	5) 处方信息中包括：唯一的编号和处方日期，且对应一位病人和一位医生。每张处 方还有开出的药品、数量、单价等。每张处方可开出多种药品。 
	回答下列问题： 
	1. 用 E-R 图建立该系统的数据库模型。 
	2. 由数据库模型建立该系统的关系模式，并确定每个关系的主键。注意各关系中的函数依赖和多值依赖，并使你的关系能符合更高的范式
	解：
	1. ![[Pasted image 20231119220502.png]]
	2. 科室(<u>科室ID</u>，科室名，地址，联系电话，*科室主任*)
	    职员(<u>员工号</u>，姓名，性别，职务，职称，电话，*科室ID*)
	    药品(<u>药品代码</u>，药品名称，规格，计量单位，价格)
	    病人信息(<u>病人代码</u>，身份证号，姓名，性别，出生日期)
	    处方(<u>编号</u>，日期，*病人*，*医生*)
	    处方明细(*药品代码*，数量，单价)
	    
#### 关系之间M:N联系转换为关系数据模型的方法
1. 先画一个多对多联系的E-R图。
2. 将E-R图中的实体类型转换为表，标出键。
3. 关系是多对多，所以将两端实体的键作为表的主键，同时两端实体的键也是外键
4. 如果关系有属性，需要注明语义。
	##### 例题：
	设工厂里产品与零件是M:N联系，er图如下：
	![[Pasted image 20230906214500.png]]
	将ER图转换为关系模型的过程：
	1. 将实体类型转换为表；实体的键就是表的键。
		产品(<u>产品号</u>，产品名，规格)
		零件(<u>零件号</u>，零件名，库存量)
	2. 两边实体的键合起来为表的主键，两表实体的键分别为表的外键，结构如下：
		构成(<u>产品号</u>，<u>零件号</u>，数量)
#### 关系模式设计不当产生的问题
1. 插入异常
	插入的数据违反数据库对象的规定，导致插入不正确的异常结果。
2. 删除异常
	数据不能被删除而导致的删除错误。
3. 更新异常
	数据不能被更新而导致的错误。



### 权限题
考虑有用户U,V,W,X和Y，其中U是T的拥有者。依次执行以下操作：
1. User U: grant select on T to V, W with grant option
	<span style="color:yellow">U授权给 V 和 W，并且拥有再次授权的能力</span>
1. User V: grant select on T to W
	<span style="color:yellow">V授权给W</span>
3. User W: grant select on T to X, Y
	<span style="color:yellow">W授权给 X 和 Y</span>
4. User U: grant select on T to Y
	<span style="color:yellow">U授权给 Y</span>
5. User U: revoke select on T from V restrict
	<span style="color:yellow">U撤回V的权限，但是因为restrict，V还授权给W，所以报错，无法撤回</span>
6. User U: revoke select on T from W cascade
	<span style="color:yellow">U撤回W的权限，因为cascade，将X和Y的权限一起撤回</span>
以下说法正确的是：
(A) V有 SELECT ON T 的权限         (B) W有授权 SELECT ON T 的权限
(C) Y没有 SELECT ON T 的权限     (D) X有 SELECT ON T 的权限

restrict：受限 删除时有下级会报错，不允许删除
cascade：级联 删除时会将所有下级一起删掉

### 等价表示
若关系 R(A,B,C,D)当前有 3 个元组，R 的等价表示共有（ ）种方式。
A)12    B)30   C)144   D)以上均不对
关系R(A,B,C,D)有3个元组,R的等价表示有144种
属性A,B,C,D可以互相切换位置，元组也是
结果为4! (A,B,C,D 4个属性) × 3! (3个元组) = 24×6 = 144

### 未分类的题目

1. 若有关系 R(A1,A2,A3,A4)，有两个键分别是 A1 和 A3，请问 R 有多少超键？
	A)4    B)12    C)16    D)24
	
	公式：3 × 2<sup>n-2</sup>     (只由键组成的超键数量)×2<sup>(关系中属性数-键的数量)</sup>
	
	A1 A3   
	A1A2 A1A3 A1A4  
	A2A3 A3A4  
	A1A2A3 A1A2A4 A1A3A4  
	A2A3A4  
	A1A2A3A4
2. 数据库中事务隔离分为 4 个级别，其中可能发生“不可重复读”的有（ 2）个。
	A)1      B)2      C)3      D)4
	[[数据库重点复习#数据库的数据读取问题|4个隔离级别]]
3. 关系 R、S 和 T 的 SQL 声明为： 
	CREATE TABLE R(e INT PRIMARY KEY, f INT); 
	CREATE TABLE S(c INT PRIMARY KEY, d INT REFERENCES R(e)); 
	若关系的当前实例为：
	![[Pasted image 20231120204530.png]]
	基于以上描述，回答问题 11-12。 
	11. 以下选项中，可以继续加入到 S 中的元组是： 
		A) (0,7) B) (2,4) C) (6,2) D) (7,0) 
		C。c属性是主键，不能重复，排除B；d属性是R表的e属性的外键，A和D的d属性的值是R表中e属性没有的值，所以排除。
		
	12. 试图从 R 中删除哪个（些）元组不会被拒绝？ 
		A) 只有(1,0)不会被拒绝             B) 只有(2,4)，(3,5)，(4,3)不会被拒绝 
		C) R中4个元组均不会被拒绝     D) R中4个元组均会被拒绝
		A。B选项的3个元组的e属性的值在S表中都有对应的外键，A属性的元组没有，创建表时也没写删除级联，所以B选项的3个元组都删不掉。
4. 若有关系 R(A,B)，当前实例如下所示。 
	![[Pasted image 20231120211801.png]]
	请给出 SQL 语句： 
	Select A,sum(B) as S,count(B) as C From R Group by A; 的执行结果。
	解：

	| A    | S   | C   |
	| ---- | --- | --- |
	| 1    | 0   | 0   |
	| 2    | 4   | 1   |
	| null | 3   | 1   |
5. 设教学数据库中有三个基本表：
	S(SNO，SNAME， AGE， SEX)，其属性分别表示学号、学生姓名、年龄、性别。
	C(CNO， CNAME， TEACHER)，其属性分别表示课程号、课程名、上课教师名。
	SC(SNO，CNO，GRADE)，其属性分别表示学号、课程号、成绩
	有如下SQL查询语句：
	```sql
	SELECT SNO
	FROM S
	WHERE NOT EXISTS (
		SELECT *
		FROM SC SC1,C
		WHERE SC1.CNO=C.CNO AND SC1.SNO='S3' AND NOT EXISTS (
			SELECT *
			FROM SC
			WHERE S.SNO=SC.SNO
			AND C.CNO=SC.CNO
		)
	);
	```
	请完成下列问题：用汉语句子描述出该SQL语句所表示的查询。
	解：最内层S.SNO=SC.SNO AND C.CNO=SC.CNO将3表连接，

  
