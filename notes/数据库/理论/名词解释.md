#### 有答案
1. **弱实体集**
	组成一个实体键码的属性中的一些或全部属于另一个实体集。
	
1. **非平凡多值依赖**
	1. B的属性都不在A中
	2. A和B都不包含R的所有属性
	则多值依赖 A →→ B 是非平凡的。
	
1. **参照完整性约束**
	要求形成参照关系的两个实体集中，参照实体的外键取值必须是被参照的实体中键的值，即参照实体的外键取值不能是被参照实体中没有的键值
	
1. **实体完整性约束**
    关系中主键的取值，必须唯一且非空。
    
1. **授权**
	用GRANT语句将数据库的操作权限授予指定的用户。
	
1. **级联**
	当被参照实体的主键值被修改或元组被删除，作为与之关联的外键的值也被修改或与之关联的外键所有元组也被删除。
	 
1. **属性的闭包**
	假设{A<sub>1</sub>A<sub>2</sub> ... A<sub>n</sub>}是属性集，S是函数依赖集。属性集{A<sub>1</sub>A<sub>2</sub> ... A<sub>n</sub>}在S下的闭包是这样的属性集B，使得满足满足函数依赖集S中的所有依赖的每个关系也都满足{A<sub>1</sub>A<sub>2</sub> ... A<sub>n</sub>} → B 。即{A<sub>1</sub>A<sub>2</sub> ... A<sub>n</sub>} → B 蕴涵于S中的函数依赖。
	
1. **最小函数依赖集**
	设 F 是 U 上的函数依赖集，F<sub>min</sub>是 F 的最小函数依赖集。F<sub>min</sub>满足下列4个条件：
	1. F<sub>min</sub><sup>+</sup> = F<sup>+</sup>
	2. 每个函数依赖的右边都是单属性。
	3. F<sub>min</sub>中不包含冗余的函数依赖（不存在这样的依赖 X→Y，使得F 与 F-|X→Y| 等价）
	4. 每个函数依赖的左边没有冗余的属性（不存在这样的属性 X→Y，X有真子集W，使得F-|X→Y| ∪ | W → Y | 与 F 等价）
	
1. **事务的原子性**  
	事务中包括的所有操作要么都做，要么都不做。
	
1. **事务的持久性**
	如果事务已经完成，即使系统出现故障，甚至事务刚刚完成，系统就出现故障，事务的结果也不能丢失。
	
1. **事务的隔离性**
	所有事务必须如同没有其他事务在同时执行一样被执行。
	
1. **事务的一致性**
	是指事务必须使数据库从一个一致性状态到另一个一致性状态。
	
1. **外连接**
    先考虑R和S的自然连接，然后把来自R和S的悬浮元组加入其中，再用null的表示符号补齐结果元组中那些不具有值的属性。称为外连接，符号为⨝(上面加个o)
    
1. **自然连接**
    在关系模式R和S的公共属性上一致的R和S的元组成对出现在结果集中，其结果集的属性是由R的属性加上S中不属于R的那些属性共同构成。
    
1. **视图**
    它本身不独立存储在数据库中，是一个虚表。即数据库中只存放视图的定义，而不存放视图所对应的数据，这些数据任存放在导出视图的基本表中。
    
1. **函数依赖的投影**
    设有关系模式R(U)及函数依赖集F，若将R分解为S(U1)和T(U2)，则S上的函数依赖：由函数依赖集推断而来，只包含S的属性。
    
1. **数据物理独立性**
	由系统提供存储结构和逻辑结构的映射，当改动存储结构时，逻辑结构可不改变，从而避免应用程序的“感知”
	
1. **数据逻辑独立性**
	数据库提供了模式与外模式的映射，实现了局部逻辑与总体逻辑之间的转换，允许局部逻辑有独立于总体逻辑的表示方法。
	
1. **日志文件**
    存储用户对数据库进行增，删，改等操作信息，当数据库发生故障时，可用该文件，起到恢复数据库数据的作用
    
1. **概念模型**
	它实际上是现实世界和机器世界的一个中间层次，是信息世界的建模，是现实世界到信息世界的第一层抽象，是数据库设计人员设计数据库的有力工具，是数据库设计人员与用户之间交流的语言
	
1. **数据模型**
	表示实体与实体之间联系的数据库的数据结构
	
1. **实体联系模型**
    描述实体集属性和联系的图示
    
1. **查询优化**
    选择一个高效执行的查询策略：一般分为高关系代数优化和存取路径与底层算法优化两种
    
1. **全局约束**
    基于元组的检查子句和断言，当对数据进行增删改时，系统会检查这些约束条件，拒绝违反约束的数据进行增删改操作
21. **元组**
    关系中除属性标题之外的另一行，描述关系中一个具体的实体
    
1. **属性**
    关系中的某一列的名称，描述该列数据的含义
    
1. **分量**
	一个元组(行)在每个属性(列)上有一个交叉点
	
1. **关系**
	关系是元组的集合而不是元组的列表。关系的属性可以随意排列，关系不会改变。
	
1. **关系模式**
	将语义相关的关系名和关系的属性所构成的集合称为关系模式
	
1. **聚集运算**
	用聚集函数的方式组合计算所有元组的运算
	
1. **外关键字**
    如果一个关系中的属性或属性集不是这个关系的关键字，但它们是另一个关系的关键字，称为外关键字
28. **函数依赖**
    设R(U)是一个关系模式，X,Y是关系R的两个属性集合，X,Y属于U，R[X, Y]是关系R在属性X∪Y上的投影，在任何时候R[X, Y]的任意两个元组中的X的属性值相等时，则它们的Y属性也相等，则称X函数决定Y，或者Y函数依赖于X，记作X→Y
29. **无损连接分解**
    如果有一个关系R，分解后的关系模式通过连接运算能够重新获得R，则称为无损连接分解
30. **游标**
    是一种方法，用于在数据库查询后将数据客体中的集合量逐一转换为数据主体中的标量
31. **联系的多重性**
    存在于实体之间的一种定量的约束关系
33. **悬挂元组**
    若R中元组与S中元组均不匹配，则在R⨝S中没有该元组出现，称这种元组为悬挂元组，悬挂元组在R中有，S中也有
34. **脏数据**
    写入后未提交，随后又被撤销的数据称为脏数据。
36. **笛卡尔积**
    对于关系模式R和S，它们的笛卡尔积表示为 R×S
    - 结果：属性集是R和S属性集合的并集。R和S中的同名属性用(关系名.属性名)区分
    - 元组是R和S的所有元组的组合，数量是MR×NS
1. **传递函数依赖**
    若X→Y, Y→Z, 且Y!→X，则Z对于X是传递函数依赖。
38. **超键**
    对于关系R，有{A1A2...An}能够函数决定关系中其他所有属性
39. **排它锁**
    若事务T获得了数据项Q上的排他锁，则事务T对Q可读也可写，其他事务对Q既不可读也不可写。
40. **数据库管理系统**
    位于用户和数据库之间具有数据定义，管理和操作的软件集合。
43. **宿主语言**
    可将sql语句嵌入程序设计语言中，并在程序执行时按照要求执行sql语句的程序设计语言成为宿主语言
44. **4NF**
	是数据库规范化级别，除了候选键以外，没有其他平凡的多值依赖。即，若关系R有非平凡多值依赖X->->Y，且X为超键，则R达到4NF
45. **触发器**
	是数据库中的一个回调函数，它会在指定的数据库事件发生时自动 调用/执行


***


#### 无答案
1. **弱实体集**  

2. **非平凡多值依赖**

3. **参照完整性约束**  

18. **实体完整性约束**

4. **授权**  

5. **事务的原子性**  
10. **事务的持久性**
15. **事务的隔离性**
25. **事务的一致性**
6. **级联**  

7. **属性的闭包**

8. **最小函数依赖集**
    
9. **外连接**
    

    
11. **视图**
    
12. **函数依赖的投影**
    
13. **数据物理独立性**
17. **数据逻辑独立性**
14. **日志文件**
    

    
16. **概念模型**
26. **数据模型**
41. **实体联系模型**
    

    
19. **查询优化**
    
20. **全局约束**
    
21. **元组**
    
22. **属性**
    
23. **聚集运算**
    
24. **自然连接**
    

    

    
27. **外关键字**
    
28. **函数依赖**
    
29. **无损连接分解**
    
30. **游标**
    
31. **联系的多重性**
    
32. **分量**
    
33. **悬挂元组**
    
34. **脏数据**
    
35. **关系模式**
    
36. **笛卡尔积**
    
37. **传递函数依赖**
    
38. **超键**
    
39. **排它锁**
    
40. **数据库管理系统**
    

    
42. **关系**
    
43. **宿主语言**
    
44. **4NF**
45. **触发器**